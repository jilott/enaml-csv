# Classes for converting ModelIndices into

from traits.api import HasTraits, List, Dict, Bool
from enaml.core.item_model import (AbstractItemModel, ALIGN_LEFT,
ITEM_IS_EDITABLE, ITEM_IS_ENABLED, ITEM_IS_SELECTABLE)

class SelectionHandler(HasTraits):
    
    '''
    Class for managing selections in the editor, including selections made on the
    list of plots, the tabular view, local workspace, etc.
    '''
    
    
    # The list returned by the get_selection() method of BaseSelectionModel
    current_selection = List
    
    # The list created to contain only the top left and bottom right indices
    # of all selections
    selected_indices = List
    
    # The dict containing the type of selected components (cells, blocks, rows,
    # columns, etc) along with their indices
    selection_dict = Dict
    
    def _current_selection_default(self):
        return []
    
    def _selected_indices_default(self):
        return []
    
    def _selection_dict_default(self):
        return {}
    
    # Converts the output of the get_selection() function into a list of 4-tuples,
    # each containing the top left and bottom right indices.
    def create_selection(self):
        '''
        Creates a list of tuples from the enaml ModelIndex objects, each pair
        corresponds to the top-left and bottom-right coordinates of a selection.
        '''
        for elem in self.current_selection:
            self.selected_indices.append(
                (elem[0].row,
                 elem[0].column,
                 elem[1].row,
                 elem[1].column)
            )
    
    # Cleans up the current selection. Needs to be called every time a
    # selection is used.
    def flush(self):
        self.current_selection = []
        self.selected_indices = []
    
    # Creates a dictionary for the current selection, useful for visualizing
    # the selected components in a tabular from.
    def create_selection_dict(self):
        '''
        Creates a dictionary out of the current selection, indicating the type,
        size and a default name for each selection.
        '''
        
        m=0
        for index in self.selected_indices:
            mydict = {}
            if index[0:2]==index[2:4]:
                mydict['type']='cell'
            elif index[1]==index[3] and index[2]!=index[0]:
                mydict['type']='row'
            elif index[0]==index[2] and index[1]!=index[3]:
                mydict['type']='column'
            mydict['topleft']=index[0:2]
            mydict['botright']=index[2:4]
            self.selection_dict[m]=mydict
            m+=1
    
    # Used for checking if the current selection is suitable for XY plotting
    def xyplot_check(self):
        '''
        Returns true if only two vectors of identical dimensions are selected.
        '''
        
        if len(self.selected_indices)>2:
            return False
        else:
            if self.selected_indices[0][0]==self.selected_indices[1][0] and \
                self.selected_indices[0][2]==self.selected_indices[1][2]:
                return True
            return False
            if self.selected_indices[0][1]==self.selected_indices[1][1] and \
                self.selected_indices[0][3]==self.selected_indices[1][3]:
                return True
            return False
    
    
        

class SelectionViewer(AbstractItemModel):
    '''
    Class for handling local workspace.
    A workspace is the set of local variables generated by the user by running a
    script in the scripting widget. 
    '''
    
    # A list containing tuple pairs, each pair contains the top left and the
    # bottom right indices of a selection.
    selection_list = Dict
    
    # Initialize atleast with an empty dict.
    def __init__(self, selection_list):
        self.selection_list = selection_list
        
    # Just something required by AbstractItemModel subclasses
    def index(self, row, column, parent=None):
        if self.has_index(row,column,parent=None):
            return self.create_index(row,column,None)
    
    # No concept of parents here, workspace is not a tree-like structure
    def parent(self, index):
        pass
    
    # No. of local variables in the workspace
    def row_count(self, idx):
        if len(self.selection_list)>0:
            return len(self.selection_list)
    
    # No. of properties of each variable that are displayed
    def column_count(self, idx):
        return 3
    
    # The properties of each variable in the workspace
    def horizontal_header_data(self, section):
        return ['Type', 'Top Left', 'Bottom Right'][section]
    
    # A function for the AbstractItemModel subclass to generate the data for
    # viewing
    def data(self, idx):
        row = idx.row
        column = idx.column
        if column == 0:
            bounds = self.selection_list[row]
            if bounds[0:2]==bounds[2:4]:
                return 'cell'
            elif bounds[0]==bounds[2] and bounds[1]!=bounds[3]:
                return 'row'
            elif bounds[1]==bounds[3] and bounds[2]!=bounds[0]:
                return 'column'
            else:
                return 'block'
        elif column == 1:
            bounds = self.selection_list[row]
            return str(bounds[0:2])
        else:
            bounds = self.selection_list[row]
            return str(bounds[2:4])

    
    def alignment(self, index):
        if index.column == 0:
            return ALIGN_LEFT
        return super(SelectionViewer, self).alignment(index)

class ScriptSelection(AbstractItemModel):
    
    base_flags = ITEM_IS_ENABLED | ITEM_IS_SELECTABLE
    
    # A list containing tuple pairs, each pair contains the top left and the
    # bottom right indices of a selection.
    selection_list = List
    
    # A dict that maps the selected vairables to a list of its attributes, which
    # include the size, indices and type of selection.
    selection_dict = Dict
    
    _editable = Bool
    
    # Initialize atleast with an empty dict.
    def __init__(self, selection_list, editable=False):
        self._data_source = selection_list
        self.selection_list = selection_list
        self._editable = editable
        self._edit_data_converter = unicode
        self.selection_dict = {}
        
    # Just something required by AbstractItemModel subclasses
    def index(self, row, column, parent=None):
        if self.has_index(row,column,parent=None):
            return self.create_index(row,column,None)
    
    # No concept of parents here, workspace is not a tree-like structure
    def parent(self, index):
        pass
    
    # No. of local variables in the workspace
    def row_count(self, idx):
        if len(self.selection_list)>0:
            return len(self.selection_list)
    
    # No. of properties of each variable that are displayed
    def column_count(self, idx):
        return 4
    
    # The properties of each variable in the workspace
    def horizontal_header_data(self, section):
        return ['Type', 'Top Left', 'Bottom Right','Variable Name'][section]
    
    def flags(self, index):
        """ Returns the flags for the items in the model.

        """
        flags = self.base_flags
        if self._editable:
            flags |= ITEM_IS_EDITABLE
        return flags
    
    
    def create_selection_dict(self):
        '''
        Called to create the selection_dict from the selection_list.
        '''
        for i in range(len(self.selection_list)):
            self.selection_dict[i] = []
            bounds = self.selection_list[i]
            if bounds[0:2]==bounds[2:4]:
                sel_type='cell'
            elif bounds[0]==bounds[2] and bounds[1]!=bounds[3]:
                sel_type = 'row'
            elif bounds[1]==bounds[3] and bounds[2]!=bounds[0]:
                sel_type = 'column'
            else:
                sel_type = 'block'
            self.selection_dict[i].append(sel_type)
            
            
            top_left = str(bounds[0:2])
            self.selection_dict[i].append(top_left)
            
            
            bot_right = str(bounds[2:4])
            self.selection_dict[i].append(bot_right)
            
            var_name = ''
            self.selection_dict[i].append(var_name)
    
    
    # A function for the AbstractItemModel subclass to generate the data for
    # viewing
    def data(self, idx, value=None):
        row = idx.row
        column = idx.column
        return self.selection_dict[row][column] 
    
    def flush(self):
        '''
        Needs to be called before making a new selection, to ensure the previous
        selection has been flushed out.
        '''
        self.selection_dict = {}
        self.selection_list = []
    
    def edit_data(self, index):
        """ Returns the data value for editing. If an edit converter is
        provided, then the unicode form of the data is returned, 
        otherwise, the raw datapoint is returned.

        """

        if self._edit_data_converter is None:
            row = index.row
            col = index.column
            return self._data_source[row, col]
        return self.selection_dict[index.row][index.column]
    
    def set_data(self, index, value):

        """ Sets the data source with the converted value, emits the 
        proper changed notification and returns True. 

        """
        converter = self._edit_data_converter
        if converter is not None:
            try:
                value = converter(value)
            except ValueError:
                return False
        row = index.row
        col = index.column
        
        self.selection_dict[row][col]=value
        self.notify_data_changed(index, index)
        return True
    
    def add_to_workspace(self):
        '''
        Returns the indices of selected objects as per the user-assigned name
        '''
        return_dict = {}
        for key in self.selection_dict:
            t = self.selection_dict[key]
            return_dict[t[3]] = [t[1],t[2]]
        return return_dict
    
    def alignment(self, index):
        if index.column == 0:
            return ALIGN_LEFT
        return super(ScriptSelection, self).alignment(index)