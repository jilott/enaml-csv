# Classes for converting ModelIndices into

from traits.api import HasTraits, List, Dict
from enaml.core.item_model import AbstractItemModel, ALIGN_LEFT

class SelectionHandler(HasTraits):
    
    # The list returned by the get_selection() method of BaseSelectionModel
    current_selection = List
    
    # The list created to contain only the top left and bottom right indices
    # of all selections
    selected_indices = List
    
    # The dict containing the type of selected components (cells, blocks, rows,
    # columns, etc) along with their indices
    selection_dict = Dict
    
    def _current_selection_default(self):
        return []
    
    def _selected_indices_default(self):
        return []
    
    def _selection_dict_default(self):
        return {}
    
    # Converts the output of the get_selection() function into a list of 4-tuples,
    # each containing the top left and bottom right indices.
    def create_selection(self):
        for elem in self.current_selection:
            self.selected_indices.append(
                (elem[0].row,
                 elem[0].column,
                 elem[1].row,
                 elem[1].column)
            )
    
    # Cleans up the current selection. Needs to be called every time a
    # selection is used.
    def flush(self):
        self.current_selection = []
        self.selected_indices = []
    
    # Creates a dictionary for the current selection, useful for visualizing
    # the selected components in a tabular from.
    def create_selection_dict(self):
        m=0
        for index in self.selected_indices:
            mydict = {}
            if index[0:2]==index[2:4]:
                mydict['type']='cell'
            elif index[1]==index[3] and index[2]!=index[0]:
                mydict['type']='row'
            elif index[0]==index[2] and index[1]!=index[3]:
                mydict['type']='column'
            mydict['topleft']=index[0:2]
            mydict['botright']=index[2:4]
            self.selection_dict[m]=mydict
            m+=1
    
    # Used for checking if the current selection is suitable for XY plotting
    def xyplot_check(self):
        if len(self.selected_indices)>2:
            return False
        else:
            if self.selected_indices[0][0]==self.selected_indices[1][0] and \
                self.selected_indices[0][2]==self.selected_indices[1][2]:
                return True
            return False
            if self.selected_indices[0][1]==self.selected_indices[1][1] and \
                self.selected_indices[0][3]==self.selected_indices[1][3]:
                return True
            return False
    
    
        

class SelectionViewer(AbstractItemModel):
    '''
    Class for handling local workspace.
    A workspace is the set of local variables generated by the user by running a
    script in the scripting widget. 
    '''
    
    selection_list = Dict
    
    # Initialize atleast with an empty dict.
    def __init__(self, selection_list):
        self.selection_list = selection_list
        
    # Just something required by AbstractItemModel subclasses
    def index(self, row, column, parent=None):
        if self.has_index(row,column,parent=None):
            return self.create_index(row,column,None)
    
    # No concept of parents here, workspace is not a tree-like structure
    def parent(self, index):
        pass
    
    # No. of local variables in the workspace
    def row_count(self, idx):
        if len(self.selection_list)>0:
            return len(self.selection_list)
    
    # No. of properties of each variable that are displayed
    def column_count(self, idx):
        return 3
    
    # The properties of each variable in the workspace
    def horizontal_header_data(self, section):
        return ['Type', 'Top Left', 'Bottom Right'][section]
    
    # A function for the AbstractItemModel subclass to generate the data for
    # viewing
    def data(self, idx):
        row = idx.row
        column = idx.column
        if column == 0:
            bounds = self.selection_list[row]
            if bounds[0:2]==bounds[2:4]:
                return 'cell'
            elif bounds[0]==bounds[2] and bounds[1]!=bounds[3]:
                return 'row'
            elif bounds[1]==bounds[3] and bounds[2]!=bounds[0]:
                return 'column'
            else:
                return 'block'
        elif column == 1:
            bounds = self.selection_list[row]
            return str(bounds[0:2])
        else:
            bounds = self.selection_list[row]
            return str(bounds[2:4])

    
    def alignment(self, index):
        if index.column == 0:
            return ALIGN_LEFT
        return super(SelectionViewer, self).alignment(index)

class ScriptSelection(AbstractItemModel):
    selection_list = List
    
    # Initialize atleast with an empty dict.
    def __init__(self, selection_list):
        self.selection_list = selection_list
        
    # Just something required by AbstractItemModel subclasses
    def index(self, row, column, parent=None):
        if self.has_index(row,column,parent=None):
            return self.create_index(row,column,None)
    
    # No concept of parents here, workspace is not a tree-like structure
    def parent(self, index):
        pass
    
    # No. of local variables in the workspace
    def row_count(self, idx):
        if len(self.selection_list)>0:
            return len(self.selection_list)
    
    # No. of properties of each variable that are displayed
    def column_count(self, idx):
        return 4
    
    # The properties of each variable in the workspace
    def horizontal_header_data(self, section):
        return ['Type', 'Top Left', 'Bottom Right','Variable Name'][section]
    
    # A function for the AbstractItemModel subclass to generate the data for
    # viewing
    def data(self, idx):
        row = idx.row
        column = idx.column
        if column == 0:
            bounds = self.selection_list[row]
            if bounds[0:2]==bounds[2:4]:
                return 'cell'
            elif bounds[0]==bounds[2] and bounds[1]!=bounds[3]:
                return 'row'
            elif bounds[1]==bounds[3] and bounds[2]!=bounds[0]:
                return 'column'
            else:
                return 'block'
        elif column == 1:
            bounds = self.selection_list[row]
            return str(bounds[0:2])
        elif column == 2:
            bounds = self.selection_list[row]
            return str(bounds[2:4])
        else:
            return ''

    
    def alignment(self, index):
        if index.column == 0:
            return ALIGN_LEFT
        return super(ScriptSelection, self).alignment(index)